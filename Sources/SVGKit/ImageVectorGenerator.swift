// swiftlint:disable file_length type_body_length
import Foundation

/// Generates Jetpack Compose ImageVector Kotlin code from parsed SVG
public struct ImageVectorGenerator: Sendable {
    /// Configuration for the generator
    public struct Config: Sendable {
        /// Package name for the generated file
        public let packageName: String
        /// Extension target (e.g., "com.example.AppIcons")
        public let extensionTarget: String?
        /// Whether to generate @Preview annotation
        public let generatePreview: Bool
        /// Color mappings to apply (from hex -> to Kotlin code)
        public let colorMappings: [String: String]

        public init(
            packageName: String,
            extensionTarget: String? = nil,
            generatePreview: Bool = true,
            colorMappings: [String: String] = [:]
        ) {
            self.packageName = packageName
            self.extensionTarget = extensionTarget
            self.generatePreview = generatePreview
            self.colorMappings = colorMappings
        }
    }

    private let config: Config

    public init(config: Config) {
        self.config = config
    }

    /// Generates Kotlin code for a single icon
    /// - Parameters:
    ///   - name: Icon name (will be converted to PascalCase)
    ///   - svg: Parsed SVG data
    /// - Returns: Complete Kotlin file content
    public func generate(name: String, svg: ParsedSVG) -> String {
        let iconName = name.toPascalCase()
        let privateVarName = "_\(name.toCamelCase())"

        var code = generateHeader()
        code += generatePackage()
        code += generateImports(svg: svg)
        code += "\n"
        code += generateIconProperty(iconName: iconName, privateVarName: privateVarName, svg: svg)
        code += "\n"
        code += generatePrivateVar(privateVarName: privateVarName)

        if config.generatePreview {
            code += "\n"
            code += generatePreview(iconName: iconName)
        }

        return code
    }

    // MARK: - Private Methods

    private func generateHeader() -> String {
        """
        // This file is auto-generated by ExFig. Do not edit manually.

        """
    }

    private func generatePackage() -> String {
        """
        package \(config.packageName)

        """
    }

    private func generateImports(svg: ParsedSVG) -> String {
        var imports = Set<String>()

        imports.insert("androidx.compose.ui.graphics.Color")
        imports.insert("androidx.compose.ui.graphics.SolidColor")
        imports.insert("androidx.compose.ui.graphics.vector.ImageVector")
        imports.insert("androidx.compose.ui.graphics.vector.path")
        imports.insert("androidx.compose.ui.unit.dp")

        // Check for stroke properties
        for path in svg.paths {
            if path.stroke != nil {
                imports.insert("androidx.compose.ui.graphics.StrokeCap")
                imports.insert("androidx.compose.ui.graphics.StrokeJoin")
            }
            if path.fillRule == .evenOdd {
                imports.insert("androidx.compose.ui.graphics.PathFillType")
            }
        }

        if config.generatePreview {
            imports.insert("androidx.compose.material3.Icon")
            imports.insert("androidx.compose.runtime.Composable")
            imports.insert("androidx.compose.ui.tooling.preview.Preview")
        }

        if config.extensionTarget != nil {
            // Extract the class/object to import
            if let target = config.extensionTarget {
                imports.insert(target)
            }
        }

        let sortedImports = imports.sorted()
        return sortedImports.map { "import \($0)" }.joined(separator: "\n") + "\n"
    }

    private func generateIconProperty(iconName: String, privateVarName: String, svg: ParsedSVG) -> String {
        let extensionPrefix: String
        if let target = config.extensionTarget {
            let targetName = target.components(separatedBy: ".").last ?? target
            extensionPrefix = "\(targetName)."
        } else {
            extensionPrefix = ""
        }

        var code = """
        public val \(extensionPrefix)\(iconName): ImageVector
            get() {
                if (\(privateVarName) != null) {
                    return \(privateVarName)!!
                }
                \(privateVarName) = ImageVector.Builder(
                    name = "\(iconName)",
                    defaultWidth = \(formatDouble(svg.width)).dp,
                    defaultHeight = \(formatDouble(svg.height)).dp,
                    viewportWidth = \(formatDouble(svg.viewportWidth))f,
                    viewportHeight = \(formatDouble(svg.viewportHeight))f,
                ).apply {

        """

        for path in svg.paths {
            code += generatePath(path)
        }

        code += """
                }.build()
                return \(privateVarName)!!
            }

        """

        return code
    }

    private func generatePrivateVar(privateVarName: String) -> String {
        """
        private var \(privateVarName): ImageVector? = null

        """
    }

    // swiftlint:disable:next cyclomatic_complexity
    private func generatePath(_ path: SVGPath) -> String {
        var params: [String] = []

        // Fill
        if let fill = path.fill {
            let colorCode = mapColor(fill)
            params.append("fill = SolidColor(\(colorCode))")
        }

        // Stroke
        if let stroke = path.stroke {
            let colorCode = mapColor(stroke)
            params.append("stroke = SolidColor(\(colorCode))")
        }

        // Stroke width
        if let strokeWidth = path.strokeWidth {
            params.append("strokeLineWidth = \(formatDouble(strokeWidth))f")
        }

        // Stroke line cap
        if let cap = path.strokeLineCap {
            let capValue = switch cap {
            case .butt: "StrokeCap.Butt"
            case .round: "StrokeCap.Round"
            case .square: "StrokeCap.Square"
            }
            params.append("strokeLineCap = \(capValue)")
        }

        // Stroke line join
        if let join = path.strokeLineJoin {
            let joinValue = switch join {
            case .miter: "StrokeJoin.Miter"
            case .round: "StrokeJoin.Round"
            case .bevel: "StrokeJoin.Bevel"
            }
            params.append("strokeLineJoin = \(joinValue)")
        }

        // Fill rule
        if let fillRule = path.fillRule {
            let ruleValue = switch fillRule {
            case .nonZero: "PathFillType.NonZero"
            case .evenOdd: "PathFillType.EvenOdd"
            }
            params.append("pathFillType = \(ruleValue)")
        }

        var code = "            path(\n"
        if !params.isEmpty {
            code += "                " + params.joined(separator: ",\n                ") + ",\n"
        }
        code += "            ) {\n"

        // Generate path commands
        code += generatePathCommands(path.commands)

        code += "            }\n"

        return code
    }

    private func generatePathCommands(_ commands: [SVGPathCommand]) -> String {
        var code = ""

        for command in commands {
            code += "                "
            code += generatePathCommand(command)
            code += "\n"
        }

        return code
    }

    // swiftlint:disable:next cyclomatic_complexity function_body_length
    private func generatePathCommand(_ command: SVGPathCommand) -> String {
        switch command {
        case let .moveTo(x, y, relative):
            if relative {
                "moveToRelative(\(formatDouble(x))f, \(formatDouble(y))f)"
            } else {
                "moveTo(\(formatDouble(x))f, \(formatDouble(y))f)"
            }

        case let .lineTo(x, y, relative):
            if relative {
                "lineToRelative(\(formatDouble(x))f, \(formatDouble(y))f)"
            } else {
                "lineTo(\(formatDouble(x))f, \(formatDouble(y))f)"
            }

        case let .horizontalLineTo(x, relative):
            if relative {
                "horizontalLineToRelative(\(formatDouble(x))f)"
            } else {
                "horizontalLineTo(\(formatDouble(x))f)"
            }

        case let .verticalLineTo(y, relative):
            if relative {
                "verticalLineToRelative(\(formatDouble(y))f)"
            } else {
                "verticalLineTo(\(formatDouble(y))f)"
            }

        case let .curveTo(x1, y1, x2, y2, x, y, relative):
            if relative {
                """
                curveToRelative(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                curveTo(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case let .smoothCurveTo(x2, y2, x, y, relative):
            if relative {
                """
                reflectiveCurveToRelative(\
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                reflectiveCurveTo(\
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case let .quadraticBezierCurveTo(x1, y1, x, y, relative):
            if relative {
                """
                quadToRelative(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                quadTo(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case let .smoothQuadraticBezierCurveTo(x, y, relative):
            if relative {
                "reflectiveQuadToRelative(\(formatDouble(x))f, \(formatDouble(y))f)"
            } else {
                "reflectiveQuadTo(\(formatDouble(x))f, \(formatDouble(y))f)"
            }

        case let .arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y, relative):
            if relative {
                """
                arcToRelative(\
                \(formatDouble(rx))f, \(formatDouble(ry))f, \
                \(formatDouble(xAxisRotation))f, \
                \(largeArcFlag), \(sweepFlag), \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                arcTo(\
                \(formatDouble(rx))f, \(formatDouble(ry))f, \
                \(formatDouble(xAxisRotation))f, \
                \(largeArcFlag), \(sweepFlag), \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case .closePath:
            "close()"
        }
    }

    private func generatePreview(iconName: String) -> String {
        let extensionPrefix: String
        if let target = config.extensionTarget {
            let targetName = target.components(separatedBy: ".").last ?? target
            extensionPrefix = "\(targetName)."
        } else {
            extensionPrefix = ""
        }

        return """
        @Preview(showBackground = true)
        @Composable
        private fun \(iconName)Preview() {
            Icon(
                imageVector = \(extensionPrefix)\(iconName),
                contentDescription = null,
            )
        }

        """
    }

    private func mapColor(_ color: SVGColor) -> String {
        // Check color mappings first
        let hexWithoutAlpha = String(format: "%02x%02x%02x", color.red, color.green, color.blue).lowercased()

        // Check for wildcard mapping
        if let mappedColor = config.colorMappings["*"] {
            return mappedColor
        }

        // Check for specific color mapping
        if let mappedColor = config.colorMappings[hexWithoutAlpha] {
            return mappedColor
        }

        // Generate Color() with hex
        return "Color(\(color.composeHex))"
    }

    private func formatDouble(_ value: Double) -> String {
        // Format to remove unnecessary trailing zeros
        if value == value.rounded(), abs(value) < 10000 {
            return String(format: "%.0f", value)
        } else if abs(value - value.rounded()) < 0.0001 {
            return String(format: "%.0f", value)
        } else {
            let formatted = String(format: "%.4f", value)
            // Remove trailing zeros after decimal point
            var result = formatted
            while result.hasSuffix("0"), !result.hasSuffix(".0") {
                result.removeLast()
            }
            if result.hasSuffix(".") {
                result.removeLast()
            }
            return result
        }
    }
}

// MARK: - String Extensions

private extension String {
    func toPascalCase() -> String {
        let components = split { !$0.isLetter && !$0.isNumber }
        return components.map { component in
            component.prefix(1).uppercased() + component.dropFirst().lowercased()
        }.joined()
    }

    func toCamelCase() -> String {
        let pascal = toPascalCase()
        guard let first = pascal.first else { return pascal }
        return first.lowercased() + pascal.dropFirst()
    }
}
