// swiftlint:disable file_length type_body_length
import Foundation

/// Generates Jetpack Compose ImageVector Kotlin code from parsed SVG
public struct ImageVectorGenerator: Sendable {
    /// Configuration for the generator
    public struct Config: Sendable {
        /// Package name for the generated file
        public let packageName: String
        /// Extension target (e.g., "com.example.AppIcons")
        public let extensionTarget: String?
        /// Whether to generate @Preview annotation
        public let generatePreview: Bool
        /// Color mappings to apply (from hex -> to Kotlin code)
        public let colorMappings: [String: String]

        public init(
            packageName: String,
            extensionTarget: String? = nil,
            generatePreview: Bool = true,
            colorMappings: [String: String] = [:]
        ) {
            self.packageName = packageName
            self.extensionTarget = extensionTarget
            self.generatePreview = generatePreview
            self.colorMappings = colorMappings
        }
    }

    private let config: Config

    public init(config: Config) {
        self.config = config
    }

    /// Generates Kotlin code for a single icon
    /// - Parameters:
    ///   - name: Icon name (will be converted to PascalCase)
    ///   - svg: Parsed SVG data
    /// - Returns: Complete Kotlin file content
    public func generate(name: String, svg: ParsedSVG) -> String {
        let iconName = name.toPascalCase()
        let privateVarName = "_\(name.toCamelCase())"

        var code = generateHeader()
        code += generatePackage()
        code += generateImports(svg: svg)
        code += "\n"
        code += generateIconProperty(iconName: iconName, privateVarName: privateVarName, svg: svg)
        code += "\n"
        code += generatePrivateVar(privateVarName: privateVarName)

        if config.generatePreview {
            code += "\n"
            code += generatePreview(iconName: iconName)
        }

        return code
    }

    // MARK: - Private Methods

    private func generateHeader() -> String {
        """
        // This file is auto-generated by ExFig. Do not edit manually.

        """
    }

    private func generatePackage() -> String {
        """
        package \(config.packageName)

        """
    }

    private func generateImports(svg: ParsedSVG) -> String {
        var imports = Set<String>()

        imports.insert("androidx.compose.ui.graphics.Color")
        imports.insert("androidx.compose.ui.graphics.SolidColor")
        imports.insert("androidx.compose.ui.graphics.vector.ImageVector")
        imports.insert("androidx.compose.ui.graphics.vector.path")
        imports.insert("androidx.compose.ui.unit.dp")

        // Check for groups
        if hasGroups(svg) {
            imports.insert("androidx.compose.ui.graphics.vector.group")
        }

        // Check for stroke properties and gradients
        for path in svg.paths {
            if path.stroke != nil {
                imports.insert("androidx.compose.ui.graphics.StrokeCap")
                imports.insert("androidx.compose.ui.graphics.StrokeJoin")
            }
            if path.fillRule == .evenOdd {
                imports.insert("androidx.compose.ui.graphics.PathFillType")
            }
            // Check for gradient fills
            switch path.fillType {
            case .linearGradient, .radialGradient:
                imports.insert("androidx.compose.ui.graphics.Brush")
                imports.insert("androidx.compose.ui.geometry.Offset")
            default:
                break
            }
        }

        if config.generatePreview {
            imports.insert("androidx.compose.material3.Icon")
            imports.insert("androidx.compose.runtime.Composable")
            imports.insert("androidx.compose.ui.tooling.preview.Preview")
        }

        if config.extensionTarget != nil {
            // Extract the class/object to import
            if let target = config.extensionTarget {
                imports.insert(target)
            }
        }

        let sortedImports = imports.sorted()
        return sortedImports.map { "import \($0)" }.joined(separator: "\n") + "\n"
    }

    private func generateIconProperty(iconName: String, privateVarName: String, svg: ParsedSVG) -> String {
        let extensionPrefix: String
        if let target = config.extensionTarget {
            let targetName = target.components(separatedBy: ".").last ?? target
            extensionPrefix = "\(targetName)."
        } else {
            extensionPrefix = ""
        }

        var code = """
        public val \(extensionPrefix)\(iconName): ImageVector
            get() {
                if (\(privateVarName) != null) {
                    return \(privateVarName)!!
                }
                \(privateVarName) = ImageVector.Builder(
                    name = "\(iconName)",
                    defaultWidth = \(formatDouble(svg.width)).dp,
                    defaultHeight = \(formatDouble(svg.height)).dp,
                    viewportWidth = \(formatDouble(svg.viewportWidth))f,
                    viewportHeight = \(formatDouble(svg.viewportHeight))f,
                ).apply {

        """

        // Generate elements in document order (preserves correct layer order)
        if !svg.elements.isEmpty {
            for element in svg.elements {
                switch element {
                case let .path(path):
                    code += generatePath(path, indent: 3)
                case let .group(group):
                    code += generateGroup(group, indent: 3)
                }
            }
        } else if let groups = svg.groups, !groups.isEmpty {
            // Fallback for backward compatibility
            for path in svg.paths {
                code += generatePath(path, indent: 3)
            }
            for group in groups {
                code += generateGroup(group, indent: 3)
            }
        } else {
            for path in svg.paths {
                code += generatePath(path, indent: 3)
            }
        }

        code += """
                }.build()
                return \(privateVarName)!!
            }

        """

        return code
    }

    private func generatePrivateVar(privateVarName: String) -> String {
        """
        private var \(privateVarName): ImageVector? = null

        """
    }

    // swiftlint:disable:next cyclomatic_complexity
    private func generatePath(_ path: SVGPath, indent: Int = 3) -> String {
        let indentStr = String(repeating: "    ", count: indent)
        let innerIndentStr = String(repeating: "    ", count: indent + 1)
        var params: [String] = []

        // Fill - check fillType first, fall back to legacy fill
        switch path.fillType {
        case let .linearGradient(gradient):
            params.append(generateLinearGradientFill(gradient, indent: indent))
        case let .radialGradient(gradient):
            params.append(generateRadialGradientFill(gradient, indent: indent))
        case let .solid(color):
            let colorCode = mapColor(color)
            params.append("fill = SolidColor(\(colorCode))")
        case .none:
            // Check legacy fill property for backward compatibility
            if let fill = path.fill {
                let colorCode = mapColor(fill)
                params.append("fill = SolidColor(\(colorCode))")
            } else if path.stroke == nil {
                // SVG spec: missing fill attribute defaults to black
                params.append("fill = SolidColor(Color.Black)")
            }
        }

        // Fill alpha (opacity on path level)
        if let opacity = path.opacity, opacity < 1.0 {
            params.append("fillAlpha = \(formatDouble(opacity))f")
        }

        // Stroke
        if let stroke = path.stroke {
            let colorCode = mapColor(stroke)
            params.append("stroke = SolidColor(\(colorCode))")
        }

        // Stroke width
        if let strokeWidth = path.strokeWidth {
            params.append("strokeLineWidth = \(formatDouble(strokeWidth))f")
        }

        // Stroke line cap
        if let cap = path.strokeLineCap {
            let capValue = switch cap {
            case .butt: "StrokeCap.Butt"
            case .round: "StrokeCap.Round"
            case .square: "StrokeCap.Square"
            }
            params.append("strokeLineCap = \(capValue)")
        }

        // Stroke line join
        if let join = path.strokeLineJoin {
            let joinValue = switch join {
            case .miter: "StrokeJoin.Miter"
            case .round: "StrokeJoin.Round"
            case .bevel: "StrokeJoin.Bevel"
            }
            params.append("strokeLineJoin = \(joinValue)")
        }

        // Fill rule
        if let fillRule = path.fillRule {
            let ruleValue = switch fillRule {
            case .nonZero: "PathFillType.NonZero"
            case .evenOdd: "PathFillType.EvenOdd"
            }
            params.append("pathFillType = \(ruleValue)")
        }

        var code = "\(indentStr)path(\n"
        if !params.isEmpty {
            code += "\(innerIndentStr)" + params.joined(separator: ",\n\(innerIndentStr)") + ",\n"
        }
        code += "\(indentStr)) {\n"

        // Generate path commands
        code += generatePathCommands(path.commands, indent: indent)

        code += "\(indentStr)}\n"

        return code
    }

    private func generateGroup(_ group: SVGGroup, indent: Int) -> String {
        let indentStr = String(repeating: "    ", count: indent)
        var params = buildGroupTransformParams(group.transform)

        // Clip path - pass as clipPathData using PathBuilder
        if let clipPath = group.clipPath {
            params.append("clipPathData = PathData { \(generateClipPathData(clipPath)) }")
        }

        var code = "\(indentStr)group(\n"
        if !params.isEmpty {
            let innerIndentStr = String(repeating: "    ", count: indent + 1)
            code += "\(innerIndentStr)" + params.joined(separator: ",\n\(innerIndentStr)") + ",\n"
        }
        code += "\(indentStr)) {\n"
        code += generateGroupContent(group, indent: indent)
        code += "\(indentStr)}\n"

        return code
    }

    private func buildGroupTransformParams(_ transform: SVGTransform?) -> [String] {
        guard let transform else { return [] }
        var params: [String] = []
        if let rotation = transform.rotation {
            params.append("rotate = \(formatDouble(rotation))f")
        }
        if let pivotX = transform.pivotX {
            params.append("pivotX = \(formatDouble(pivotX))f")
        }
        if let pivotY = transform.pivotY {
            params.append("pivotY = \(formatDouble(pivotY))f")
        }
        if let scaleX = transform.scaleX, scaleX != 1.0 {
            params.append("scaleX = \(formatDouble(scaleX))f")
        }
        if let scaleY = transform.scaleY, scaleY != 1.0 {
            params.append("scaleY = \(formatDouble(scaleY))f")
        }
        if let translateX = transform.translateX {
            params.append("translationX = \(formatDouble(translateX))f")
        }
        if let translateY = transform.translateY {
            params.append("translationY = \(formatDouble(translateY))f")
        }
        return params
    }

    private func generateGroupContent(_ group: SVGGroup, indent: Int) -> String {
        var code = ""
        if !group.elements.isEmpty {
            for element in group.elements {
                switch element {
                case let .path(path):
                    code += generatePath(path, indent: indent + 1)
                case let .group(childGroup):
                    code += generateGroup(childGroup, indent: indent + 1)
                }
            }
        } else {
            // Fallback for backward compatibility
            for path in group.paths {
                code += generatePath(path, indent: indent + 1)
            }
            for childGroup in group.children {
                code += generateGroup(childGroup, indent: indent + 1)
            }
        }
        return code
    }

    private func generateClipPathData(_ pathData: String) -> String {
        // Parse path data and convert to Compose path commands
        // For simplicity, we pass the raw path data string
        // In a full implementation, this would parse and convert each command
        pathData
    }

    private func hasGroups(_ svg: ParsedSVG) -> Bool {
        if !svg.elements.isEmpty {
            return svg.elements.contains { element in
                if case .group = element { return true }
                return false
            }
        }
        return svg.groups?.isEmpty == false
    }

    private func generatePathCommands(_ commands: [SVGPathCommand], indent: Int = 3) -> String {
        var code = ""
        let innerIndentStr = String(repeating: "    ", count: indent + 1)

        for command in commands {
            code += innerIndentStr
            code += generatePathCommand(command)
            code += "\n"
        }

        return code
    }

    // swiftlint:disable:next cyclomatic_complexity function_body_length
    private func generatePathCommand(_ command: SVGPathCommand) -> String {
        switch command {
        case let .moveTo(x, y, relative):
            if relative {
                "moveToRelative(\(formatDouble(x))f, \(formatDouble(y))f)"
            } else {
                "moveTo(\(formatDouble(x))f, \(formatDouble(y))f)"
            }

        case let .lineTo(x, y, relative):
            if relative {
                "lineToRelative(\(formatDouble(x))f, \(formatDouble(y))f)"
            } else {
                "lineTo(\(formatDouble(x))f, \(formatDouble(y))f)"
            }

        case let .horizontalLineTo(x, relative):
            if relative {
                "horizontalLineToRelative(\(formatDouble(x))f)"
            } else {
                "horizontalLineTo(\(formatDouble(x))f)"
            }

        case let .verticalLineTo(y, relative):
            if relative {
                "verticalLineToRelative(\(formatDouble(y))f)"
            } else {
                "verticalLineTo(\(formatDouble(y))f)"
            }

        case let .curveTo(x1, y1, x2, y2, x, y, relative):
            if relative {
                """
                curveToRelative(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                curveTo(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case let .smoothCurveTo(x2, y2, x, y, relative):
            if relative {
                """
                reflectiveCurveToRelative(\
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                reflectiveCurveTo(\
                \(formatDouble(x2))f, \(formatDouble(y2))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case let .quadraticBezierCurveTo(x1, y1, x, y, relative):
            if relative {
                """
                quadToRelative(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                quadTo(\
                \(formatDouble(x1))f, \(formatDouble(y1))f, \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case let .smoothQuadraticBezierCurveTo(x, y, relative):
            if relative {
                "reflectiveQuadToRelative(\(formatDouble(x))f, \(formatDouble(y))f)"
            } else {
                "reflectiveQuadTo(\(formatDouble(x))f, \(formatDouble(y))f)"
            }

        case let .arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y, relative):
            if relative {
                """
                arcToRelative(\
                \(formatDouble(rx))f, \(formatDouble(ry))f, \
                \(formatDouble(xAxisRotation))f, \
                \(largeArcFlag), \(sweepFlag), \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            } else {
                """
                arcTo(\
                \(formatDouble(rx))f, \(formatDouble(ry))f, \
                \(formatDouble(xAxisRotation))f, \
                \(largeArcFlag), \(sweepFlag), \
                \(formatDouble(x))f, \(formatDouble(y))f)
                """
            }

        case .closePath:
            "close()"
        }
    }

    private func generatePreview(iconName: String) -> String {
        let extensionPrefix: String
        if let target = config.extensionTarget {
            let targetName = target.components(separatedBy: ".").last ?? target
            extensionPrefix = "\(targetName)."
        } else {
            extensionPrefix = ""
        }

        return """
        @Preview(showBackground = true)
        @Composable
        private fun \(iconName)Preview() {
            Icon(
                imageVector = \(extensionPrefix)\(iconName),
                contentDescription = null,
            )
        }

        """
    }

    private func mapColor(_ color: SVGColor) -> String {
        // Check color mappings first
        let hexWithoutAlpha = String(format: "%02x%02x%02x", color.red, color.green, color.blue).lowercased()

        // Check for wildcard mapping
        if let mappedColor = config.colorMappings["*"] {
            return mappedColor
        }

        // Check for specific color mapping
        if let mappedColor = config.colorMappings[hexWithoutAlpha] {
            return mappedColor
        }

        // Generate Color() with hex
        return "Color(\(color.composeHex))"
    }

    private func formatDouble(_ value: Double) -> String {
        // Format to remove unnecessary trailing zeros
        if value == value.rounded(), abs(value) < 10000 {
            return String(format: "%.0f", value)
        } else if abs(value - value.rounded()) < 0.0001 {
            return String(format: "%.0f", value)
        } else {
            let formatted = String(format: "%.4f", value)
            // Remove trailing zeros after decimal point
            var result = formatted
            while result.hasSuffix("0"), !result.hasSuffix(".0") {
                result.removeLast()
            }
            if result.hasSuffix(".") {
                result.removeLast()
            }
            return result
        }
    }

    // MARK: - Gradient Generation

    private func generateLinearGradientFill(_ gradient: SVGLinearGradient, indent: Int = 3) -> String {
        let innerIndentStr = String(repeating: "    ", count: indent + 1)
        let innerInnerIndentStr = String(repeating: "    ", count: indent + 2)

        // Apply gradientTransform if present
        var x1 = gradient.x1
        var y1 = gradient.y1
        var x2 = gradient.x2
        var y2 = gradient.y2

        if let transform = gradient.gradientTransform {
            (x1, y1) = applyTransformToPoint(x: x1, y: y1, transform: transform)
            (x2, y2) = applyTransformToPoint(x: x2, y: y2, transform: transform)
        }

        var code = "fill = Brush.linearGradient(\n"
        code += "\(innerIndentStr)colorStops = arrayOf(\n"

        for stop in gradient.stops {
            let colorHex = colorToComposeHex(stop.color, opacity: stop.opacity)
            code += "\(innerInnerIndentStr)\(formatDouble(stop.offset))f to Color(\(colorHex)),\n"
        }

        code += "\(innerIndentStr)),\n"
        code += "\(innerIndentStr)start = Offset(\(formatDouble(x1))f, \(formatDouble(y1))f),\n"
        code += "\(innerIndentStr)end = Offset(\(formatDouble(x2))f, \(formatDouble(y2))f),\n"
        code += "\(String(repeating: "    ", count: indent)))"

        return code
    }

    private func generateRadialGradientFill(_ gradient: SVGRadialGradient, indent: Int = 3) -> String {
        let innerIndentStr = String(repeating: "    ", count: indent + 1)
        let innerInnerIndentStr = String(repeating: "    ", count: indent + 2)

        // Apply gradientTransform if present
        var cx = gradient.cx
        var cy = gradient.cy
        var r = gradient.r

        if let transform = gradient.gradientTransform {
            (cx, cy) = applyTransformToPoint(x: cx, y: cy, transform: transform)
            // Scale radius by average of scaleX and scaleY
            let scaleX = transform.scaleX ?? 1.0
            let scaleY = transform.scaleY ?? 1.0
            r *= (abs(scaleX) + abs(scaleY)) / 2.0
        }

        var code = "fill = Brush.radialGradient(\n"
        code += "\(innerIndentStr)colorStops = arrayOf(\n"

        for stop in gradient.stops {
            let colorHex = colorToComposeHex(stop.color, opacity: stop.opacity)
            code += "\(innerInnerIndentStr)\(formatDouble(stop.offset))f to Color(\(colorHex)),\n"
        }

        code += "\(innerIndentStr)),\n"
        code += "\(innerIndentStr)center = Offset(\(formatDouble(cx))f, \(formatDouble(cy))f),\n"
        code += "\(innerIndentStr)radius = \(formatDouble(r))f,\n"
        code += "\(String(repeating: "    ", count: indent)))"

        return code
    }

    /// Applies an SVG transform to a point
    private func applyTransformToPoint(x: Double, y: Double, transform: SVGTransform) -> (Double, Double) {
        var newX = x
        var newY = y

        // Apply scale
        if let scaleX = transform.scaleX {
            newX *= scaleX
        }
        if let scaleY = transform.scaleY {
            newY *= scaleY
        }

        // Apply rotation (around origin or pivot point)
        if let rotation = transform.rotation {
            let radians = rotation * .pi / 180.0
            let cosR = cos(radians)
            let sinR = sin(radians)
            let pivotX = transform.pivotX ?? 0
            let pivotY = transform.pivotY ?? 0

            let dx = newX - pivotX
            let dy = newY - pivotY
            newX = pivotX + dx * cosR - dy * sinR
            newY = pivotY + dx * sinR + dy * cosR
        }

        // Apply translation
        if let translateX = transform.translateX {
            newX += translateX
        }
        if let translateY = transform.translateY {
            newY += translateY
        }

        return (newX, newY)
    }

    private func colorToComposeHex(_ color: SVGColor, opacity: Double) -> String {
        let alpha = Int((opacity * 255).rounded())
        return String(format: "0x%02X%02X%02X%02X", alpha, color.red, color.green, color.blue)
    }
}

// MARK: - String Extensions

private extension String {
    func toPascalCase() -> String {
        let components = split { !$0.isLetter && !$0.isNumber }
        return components.map { component in
            component.prefix(1).uppercased() + component.dropFirst().lowercased()
        }.joined()
    }

    func toCamelCase() -> String {
        let pascal = toPascalCase()
        guard let first = pascal.first else { return pascal }
        return first.lowercased() + pascal.dropFirst()
    }
}
